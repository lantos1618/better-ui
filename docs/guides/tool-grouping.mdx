---
title: "Tool Grouping"
description: "Collapse repeated tool calls into a single, always-up-to-date card"
---

## The Problem

When the AI calls the same tool multiple times (e.g., updating a task list 10 times), each call renders as a separate card in the thread. This creates a wall of UI that's hard to read.

## The Solution

Add a `groupKey` to your tool. Calls with the same group key are grouped — the first call (the "anchor") stays visible and is automatically updated with the latest data. Subsequent calls (followups) render nothing.

```tsx
const taskList = tool({
  name: 'taskList',
  groupKey: (input) => input.listId || 'default',
  input: z.object({
    listId: z.string().optional(),
    action: z.enum(['create', 'update']),
    tasks: z.array(z.object({ /* ... */ })),
  }),
  // ...
});
```

## How It Works

1. Each tool call gets an `entityId` computed as `"toolName:groupKey(input)"`
2. Tool calls with the same `entityId` belong to the same group
3. Each call gets an auto-incrementing `seqNo` (sequence number)
4. The first call in a group is the **anchor** — it remains visible in the thread
5. Later calls are **followups** — they update the anchor's output data in-place and render nothing

### Visual

```
AI calls taskList({ listId: 'tasks', action: 'create', tasks: [A] })
  → Anchor renders: taskList card showing [A]

AI calls taskList({ listId: 'tasks', action: 'update', tasks: [A, B] })
  → Anchor updates in-place: taskList card now shows [A, B]
  → Followup renders nothing

AI calls taskList({ listId: 'tasks', action: 'update', tasks: [A, B, C] })
  → Anchor updates in-place: taskList card now shows [A, B, C]
  → Both followups render nothing
```

The user sees a single card that always shows the latest state — no stacking, no collapsed chips.

## Anchor / Followup Pattern

Internally, `ToolResult` uses the store's `findAnchor(entityId)` method:

- **Anchor**: The oldest entry (lowest `seqNo`) with a given `entityId`. This is the component that renders the view.
- **Followup**: Any entry with the same `entityId` but a higher `seqNo`. On mount, it updates the anchor's output and renders `null`.

This means the anchor card stays in its original position in the thread and always reflects the latest data.

## When to Use

Use `groupKey` when:
- The AI updates the same entity multiple times (task lists, progress, dashboards)
- Multiple calls represent versions of the same data
- The latest state is all the user needs to see

Don't use `groupKey` when:
- Each tool call represents independent data (weather for different cities)
- Users need to see all results simultaneously

## Multi-Entity Groups

Different group keys create independent groups:

```tsx
const taskList = tool({
  name: 'taskList',
  groupKey: (input) => input.listId || 'default',
});

// These are separate groups — both render as anchors:
taskList({ listId: 'shopping', action: 'create', tasks: [...] })
taskList({ listId: 'work', action: 'create', tasks: [...] })

// This updates the "shopping" anchor in-place:
taskList({ listId: 'shopping', action: 'update', tasks: [...] })
```

## Panel Behavior

The multi-item Panel also uses entity grouping. It calls `getLatestPerEntity()` to show one entry per entity — so users see one task list card, one weather card, etc. — not duplicates.
