---
title: "Tool Grouping"
description: "Collapse repeated tool calls into a single card"
---

## The Problem

When the AI calls the same tool multiple times (e.g., updating a task list 10 times), each call renders as a separate card in the thread. This creates a wall of UI that's hard to read.

## The Solution

Add a `groupKey` to your tool. Calls with the same group key collapse — only the latest renders fully. Earlier calls become minimal chips.

```tsx
const taskList = tool({
  name: 'taskList',
  groupKey: (input) => input.listId || 'default',
  input: z.object({
    listId: z.string().optional(),
    action: z.enum(['create', 'update']),
    tasks: z.array(z.object({ /* ... */ })),
  }),
  // ...
});
```

## How It Works

1. Each tool call gets an `entityId` computed as `"toolName:groupKey(input)"`
2. Tool calls with the same `entityId` belong to the same group
3. Each call gets an auto-incrementing `seqNo` (sequence number)
4. In the thread, only the highest `seqNo` per group renders the full view
5. Earlier calls render as collapsed chips

### Visual

```
AI calls taskList({ listId: 'tasks', action: 'create', tasks: [...] })
  → Full card: "taskList" with task list UI

AI calls taskList({ listId: 'tasks', action: 'update', tasks: [...] })
  → Previous card collapses to chip: ● taskList
  → New full card: "taskList" with updated task list UI

AI calls taskList({ listId: 'tasks', action: 'update', tasks: [...] })
  → Two collapsed chips: ● taskList  ● taskList
  → One full card: latest task list UI
```

## Collapsed Chip

Collapsed tool calls render as a minimal inline element:

```
● taskList
```

This keeps the thread readable while preserving the history.

## When to Use

Use `groupKey` when:
- The AI updates the same entity multiple times (task lists, progress, dashboards)
- Multiple calls represent versions of the same data
- The latest state is all the user needs to see

Don't use `groupKey` when:
- Each tool call represents independent data (weather for different cities)
- Users need to see all results simultaneously

## Multi-Entity Groups

Different group keys create independent groups:

```tsx
const taskList = tool({
  name: 'taskList',
  groupKey: (input) => input.listId || 'default',
});

// These are separate groups — both render fully:
taskList({ listId: 'shopping', action: 'create', tasks: [...] })
taskList({ listId: 'work', action: 'create', tasks: [...] })

// This collapses the first shopping call:
taskList({ listId: 'shopping', action: 'update', tasks: [...] })
```

## Panel Behavior

The multi-item Panel also uses entity grouping. It shows the latest state per entity, so users see one task list card, one weather card, etc. — not duplicates.
