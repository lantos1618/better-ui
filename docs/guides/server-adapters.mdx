---
title: "Server Adapters"
description: "Use Better UI with Next.js, Express, Vite, or any Node.js framework"
---

## Next.js (App Router)

Better UI works natively with Next.js App Router:

```ts
// app/api/chat/route.ts
import { streamText, convertToModelMessages } from 'ai';
import { openai } from '@ai-sdk/openai';
import { weatherTool } from '@/lib/tools';

export async function POST(req: Request) {
  const { messages } = await req.json();

  const result = await streamText({
    model: openai('gpt-4o'),
    messages: convertToModelMessages(messages),
    tools: { weather: weatherTool.toAITool() },
  });

  return result.toUIMessageStreamResponse();
}
```

### Tool Execution Route

Create a route that executes tools server-side when the client calls `onAction`:

```ts
// app/api/tools/execute/route.ts
import { weatherTool, searchTool } from '@/lib/tools';
import type { Tool } from '@lantos1618/better-ui';

const tools: Record<string, Tool> = {
  weather: weatherTool,
  search: searchTool,
};

export async function POST(req: Request) {
  const { tool: toolName, input } = await req.json();
  const toolDef = tools[toolName];

  if (!toolDef) {
    return Response.json({ error: 'Unknown tool' }, { status: 400 });
  }

  const result = await toolDef.run(input, { isServer: true });
  return Response.json({ result });
}
```

### HITL Confirmation Route

If you use tools with `confirm: true`, add a separate confirmation endpoint:

```ts
// app/api/tools/confirm/route.ts
import { weatherTool, sendEmailTool } from '@/lib/tools';
import type { Tool } from '@lantos1618/better-ui';

const tools: Record<string, Tool> = {
  weather: weatherTool,
  sendEmail: sendEmailTool,
};

export async function POST(req: Request) {
  const { tool: toolName, input } = await req.json();
  const toolDef = tools[toolName];

  if (!toolDef) {
    return Response.json({ error: 'Unknown tool' }, { status: 400 });
  }

  // Optional: add audit logging for confirmed actions
  console.log(`[audit] Tool confirmed: ${toolName}`);

  const result = await toolDef.run(input, { isServer: true });
  return Response.json({ result });
}
```

## Express / Vite

For Express, Vite, or any Node.js server, use the tool's `.run()` method directly:

```ts
import express from 'express';
import { weatherTool, searchTool } from './lib/tools';
import type { Tool } from '@lantos1618/better-ui';

const app = express();
app.use(express.json());

const tools: Record<string, Tool> = {
  weather: weatherTool,
  search: searchTool,
};

// Tool execution endpoint
app.post('/api/tools/execute', async (req, res) => {
  const { tool: toolName, input } = req.body;
  const toolDef = tools[toolName];

  if (!toolDef) {
    return res.status(400).json({ error: 'Unknown tool' });
  }

  try {
    const result = await toolDef.run(input, {
      isServer: true,
      headers: req.headers as any,
      user: (req as any).user,
    });
    return res.json({ result });
  } catch (error: any) {
    return res.status(500).json({ error: error.message });
  }
});

// HITL confirmation endpoint
app.post('/api/tools/confirm', async (req, res) => {
  const { tool: toolName, input } = req.body;
  const toolDef = tools[toolName];

  if (!toolDef) {
    return res.status(400).json({ error: 'Unknown tool' });
  }

  try {
    const result = await toolDef.run(input, { isServer: true });
    return res.json({ result });
  } catch (error: any) {
    return res.status(500).json({ error: error.message });
  }
});

app.listen(3001);
```

## Custom Server

For any framework, the pattern is the same — parse the request, look up the tool, and call `.run()`:

```ts
import { weatherTool } from './tools';
import type { Tool } from '@lantos1618/better-ui';

const tools: Record<string, Tool> = { weather: weatherTool };

async function handleToolExecution(req: any, res: any) {
  const { tool: toolName, input } = req.body;
  const toolDef = tools[toolName];

  if (!toolDef) {
    return res.status(400).json({ error: 'Unknown tool' });
  }

  try {
    const result = await toolDef.run(input, {
      isServer: true,
      headers: req.headers,
      user: req.user,
    });
    return res.json({ result });
  } catch (error: any) {
    return res.status(500).json({ error: error.message });
  }
}
```

## Tool Context

All server handlers receive a `ToolContext` with server-specific fields:

```ts
weatherTool.server(async (input, ctx) => {
  // ctx.isServer — always true on server
  // ctx.env — environment variables
  // ctx.headers — request headers
  // ctx.cookies — parsed cookies
  // ctx.user — authenticated user (set by your middleware)
  // ctx.session — session data
  // ctx.cache — shared cache map
  // ctx.fetch — fetch function (can be customized)

  const apiKey = ctx.env?.WEATHER_API_KEY;
  const userId = ctx.user?.id;

  return { temp: 72, condition: 'Sunny' };
});
```

These fields are automatically stripped on the client to prevent accidental leakage of server secrets.

## Required Endpoints

Better UI expects these endpoints by default:

| Endpoint | Purpose | When needed |
|----------|---------|-------------|
| `/api/chat` | Chat streaming (via AI SDK) | Always |
| `/api/tools/execute` | Tool execution from `onAction` | When tools have interactive views |
| `/api/tools/confirm` | HITL tool confirmation | When tools use `confirm: true` |

The tool execution endpoint can be customized per-tool via `clientFetch`:

```tsx
const weather = tool({
  name: 'weather',
  clientFetch: { endpoint: '/api/custom/tools' },
  // ...
});
```
